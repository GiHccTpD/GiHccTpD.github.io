<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>加州提子面包</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.pikbug.me/"/>
  <updated>2017-04-11T06:32:40.000Z</updated>
  <id>http://blog.pikbug.me/</id>
  
  <author>
    <name>MiG</name>
    <email>yanrancanfei@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>十大经典排序算法</title>
    <link href="http://blog.pikbug.me/2017/04/11/JS-Sorting-Algorithm/"/>
    <id>http://blog.pikbug.me/2017/04/11/JS-Sorting-Algorithm/</id>
    <published>2017-04-11T06:24:42.000Z</published>
    <updated>2017-04-11T06:32:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="『转载』十大经典排序算法"><a href="#『转载』十大经典排序算法" class="headerlink" title="『转载』十大经典排序算法"></a>『转载』十大经典排序算法</h1><p><a href="https://sort.hust.cc/" target="_blank" rel="external">https://sort.hust.cc/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;『转载』十大经典排序算法&quot;&gt;&lt;a href=&quot;#『转载』十大经典排序算法&quot; class=&quot;headerlink&quot; title=&quot;『转载』十大经典排序算法&quot;&gt;&lt;/a&gt;『转载』十大经典排序算法&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://sort.hust.cc/
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.pikbug.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习" scheme="http://blog.pikbug.me/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="JavaScript" scheme="http://blog.pikbug.me/tags/JavaScript/"/>
    
      <category term="数据结构与算法" scheme="http://blog.pikbug.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://blog.pikbug.me/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-ways-of-create-object</title>
    <link href="http://blog.pikbug.me/2017/04/09/JavaScript-ways-of-create-object/"/>
    <id>http://blog.pikbug.me/2017/04/09/JavaScript-ways-of-create-object/</id>
    <published>2017-04-08T16:41:56.000Z</published>
    <updated>2017-04-11T08:31:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>注意：</em> 本文来自阅读《JavaScript高级程序设计（第三版）》的笔记2或者也可以称作是书摘吧👾</p>
</blockquote>
<a id="more"></a>
<h2 id="一般方式"><a href="#一般方式" class="headerlink" title="一般方式"></a>一般方式</h2><ul>
<li>构造函数</li>
<li>对象字面量</li>
</ul>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>这种模式抽象了创建具体对象的过程。如下例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    o.name =  name;</div><div class="line">    o.age = age;</div><div class="line">    o.job = job;</div><div class="line">    o.sayName = functioin () &#123;</div><div class="line">        alert (<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实例化两个类</span></div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'xixi'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">'waXaw'</span>, <span class="number">27</span>, <span class="string">'teacher'</span>);</div></pre></td></tr></table></figure>
<p>虽然解决了常见太多相似类的问题，但却没有解决对象识别的问题。</p>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>像 <code>Array</code> 和 <code>Object</code> 这样的原生构造函数，在运行时会自动创建执行环境，还可以自定义对象属性和方法。如下例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name =  name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = functioin () &#123;</div><div class="line">        alert (<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实例化两个类</span></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'xixi'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'waXaw'</span>, <span class="number">27</span>, <span class="string">'teacher'</span>);</div></pre></td></tr></table></figure>
<p>与之前的工厂模式对比可以有以下发现：</p>
<ul>
<li>没有显式地创建对象</li>
<li>直接将属性和方法赋给了 <code>this</code> 对象</li>
<li>没有 <code>return</code> 语句</li>
</ul>
<p><em>注意：</em> 构造函数应该以一个大写字母开头</p>
<p>实例化一个对象，要经过以下步骤：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋值给新对象（因此 <code>this</code> 就指向了这个新对象）</li>
<li>执行构造函数中的代码（为这个类对象添加属性）</li>
<li>返回对象</li>
</ol>
<p><code>person1</code> 和 <code>person2</code> 分别保存着 <code>Person</code> 类的一个不同的实例。 这个两个对象都有一个 <code>constructor</code> （构造函数）属性，该属性指向 <code>Person</code>。<br>创建自定义的构造函数意味着将来可以将它的实例为一种特定的类型，此处正是构造函数模式胜过工厂模式的地方。</p>
<p>构造函数是一种特殊的函数，他可以通过 <code>new</code> 操作符来调用。</p>
<h3 id="构造函数调用方式："><a href="#构造函数调用方式：" class="headerlink" title="构造函数调用方式："></a>构造函数调用方式：</h3><ul>
<li>1.当做构造函数使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'xixi'</span>, <span class="number">29</span>, <span class="string">'Software Engneer'</span>);</div><div class="line">person.sayName(); <span class="comment">//'xixi'</span></div></pre></td></tr></table></figure>
<ul>
<li>2.作为普通函数使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Person(<span class="string">'waXaw'</span>, <span class="number">24</span>, <span class="string">'Teacher'</span>);</div><div class="line"><span class="built_in">window</span>.sayName(); <span class="comment">//'waXaw'</span></div></pre></td></tr></table></figure>
<ul>
<li>3.在对象的另一个作用域中调用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">Person.call(o, <span class="string">'mig'</span>, <span class="number">23</span>, <span class="string">'CEO'</span>);</div><div class="line">o.sayName(); <span class="comment">//'mig'</span></div></pre></td></tr></table></figure>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>构造函数的方法 （即 <code>sayName</code> ）每次都要重新创建一遍。也就是说 <code>person1</code> 和 <code>person2</code> 的 <code>sayName</code> 不是同一个 <code>Function</code> 创建的。<br>可以通过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(person1.sayName === person2.sayName()); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><strong>解决方法：</strong><br>函数定义转移到构造函数的外部。如下例所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name =  name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName =sayName;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">functioin sayName() &#123;</div><div class="line">        alert (<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 实例化两个类</span></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'xixi'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'waXaw'</span>, <span class="number">27</span>, <span class="string">'Teacher'</span>);</div></pre></td></tr></table></figure>
<p><strong>新的问题：</strong></p>
<ul>
<li><code>sayName</code> 使得全局变量名不副实</li>
<li>自定义的引用类型没有了封装性可言</li>
</ul>
<h2 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h2><blockquote>
<p><strong>原型（ <code>prototype</code> ）属性：</strong></p>
<p>这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。<code>prototype</code> 就是通过构造函数而创建的那个对象实例的原型对象。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">'Nicholas'</span>;</div><div class="line">Person.prototype.age = <span class="number">29</span>;</div><div class="line">Person.prototype.job = <span class="string">'Software Engneer'</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line">person1.sayName(); <span class="comment">// 'Nicholas'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person2.sayName(); <span class="comment">// 'Nicholas'</span></div><div class="line"></div><div class="line">alert(person1.sayName === person2.sayName); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h3><p>当创建一个新函数的时候，就会创建一个 <code>prototype</code> 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象会自动获得一个  <code>constractor</code> （构造函数）属性，这个属性包含一个指向 <code>prototype</code> 属性所在函数的指针。如图所示，<code>Person.prototype.constructor</code> 指向 <code>Person</code> 。也就是说，可以通过这个构造函数为原型对象添加其他属性和方法。 </p>
<p><a href="JavaScript-ways-of-create-object/prototype.png">prototype</a> </p>
<blockquote>
<p><strong>注意：</strong> 虽然可以通过对象实例访问保存在原型中的值，却不能通过对象实例重写原型中的值。</p>
<p>如果在实例中添加一个属性，该属性与实例中的一个属性同名，那在实例中常见该对象，该属性会将原型中的那个属性屏蔽。</p>
<p><code>hasOwnProperty()</code> 方法可以检测一个属性存在于实例中还是原型中。这个方法只在给定属性存在于对象实例中时，就会返回 <code>true</code> 。</p>
</blockquote>
<h3 id="原型与-in-操作符"><a href="#原型与-in-操作符" class="headerlink" title="原型与 in 操作符"></a>原型与 <code>in</code> 操作符</h3><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ul>
<li>单独使用。 <code>in</code> 操作符会在通过对象能够访问对象时返回 <code>true</code> ，无论存在于实例还是原型中。</li>
<li><code>for-in</code> 循环。返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，既包括存在于实例中的属性和原型中的属性。不可枚举的 <code>constructor</code> 属性，可以通过 <code>Object.keys()</code> 和 <code>Object.getOwnPropertyName()</code> 方法来替代 <code>for-in</code> 循环。</li>
</ul>
<h4 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h4><p>可以通过如下方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'Nicholas'</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">29</span>,</div><div class="line">  <span class="attr">job</span>: <span class="string">'Software Engineer'</span>,</div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的代码将 <code>Person.prototype</code> 设置为等于一个以对象字面量形式创建的对象。</p>
<p><strong>例外</strong> <code>constructor</code> 属性不再指向 <code>Person</code> 。</p>
<p>为了解决上面的问题，可以如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: Person,</div><div class="line">  <span class="attr">name</span>: <span class="string">'Nicholas'</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">29</span>,</div><div class="line">  <span class="attr">job</span>: <span class="string">'Software Engineer'</span>,</div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 以此方式重设 <code>constructor</code> 属性将会导致他的 <code>[[Enumerable]]</code> 特性被设置为 <code>true</code> 默认情况下， <code>constructor</code> 属性是不可枚举的</p>
</blockquote>
<h3 id="原型的动态"><a href="#原型的动态" class="headerlink" title="原型的动态"></a>原型的动态</h3><blockquote>
<p><strong>注意：</strong> 实例中的指针仅指向原型，而不是指向构造函数。</p>
</blockquote>
<h3 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h3><ul>
<li><p>可以取得默认方法的引用。例如。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort);  <span class="comment">// 'function'</span></div><div class="line">alert(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.substring);   <span class="comment">//function</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>还可以定义新方法</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.prototype.startWith = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(text) === <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> msg = <span class="string">'Hello World!'</span>;</div><div class="line">alert(msg.startWith(<span class="string">'Hello'</span>));   <span class="comment">//true</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 不建议在产品化的程序中修改原生对象的原型。</p>
</blockquote>
<h3 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h3><ul>
<li>省略了为构造函数传递初始化参数这一环节，导致所有实例在默认情况下都将取得相同的属性值。</li>
<li>最大的问题在于其共享的本性导致的。原型中所有属性都是实例共享的。对于函数适合。但是对于类型值的属性来说，问题就突出了。</li>
</ul>
<h2 id="组合使用构造函数和原型模式"><a href="#组合使用构造函数和原型模式" class="headerlink" title="组合使用构造函数和原型模式"></a>组合使用构造函数和原型模式</h2><blockquote>
<p>创建自定义类型的最常见方式。</p>
</blockquote>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>构造函数模式用于定义实例属性；原型模式用于定义方法和共享的属性。</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul>
<li>每个实例都会有自己的一份实例属性的副本</li>
<li>但同时又共享着对方法的引用</li>
<li>最大限度的节省内存。</li>
<li>还支持向构造函数传递参数</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="keyword">this</span>.friends = [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: Person,</div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'SoftWare Engineer'</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Greg'</span>, <span class="number">27</span>, <span class="string">'Doctor'</span>);</div><div class="line"></div><div class="line">person1.friends.push(<span class="string">'Van'</span>);</div><div class="line">alert(person1.friends); <span class="comment">// 'Shelby, Court, Van'</span></div><div class="line">alert(person2.friends); <span class="comment">// 'Shelby, Court'</span></div><div class="line">alert(person1.friends === person2.friends); </div><div class="line">  <span class="comment">// false</span></div><div class="line">alert(person1.sayName === person2.sayName);</div><div class="line">  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>此种方式是目前 <code>ECMAScript</code> 中使用<strong>最广泛</strong>、<strong>认同度最高</strong>的一种创建自定义类型的方法。 换句话说，这是用来定义引用类型的一种默认模式。</p>
<h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><p>动态原型模式将所有信息封装在构造函数中，而通过在构造函数中初始化原型（<strong>仅在必要的情况下</strong>），又保持了同事使用构造函数和原型的优点。如例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="comment">// 属性</span></div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="comment">// 方法</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">'function'</span>) &#123;</div><div class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure>
<h2 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h2><blockquote>
<p>主要思想： 创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后返回新的对象。下面是例子。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> o = &#123;&#125;;</div><div class="line">  o.name = name;</div><div class="line">  o.age = age;</div><div class="line">  o.job = job;</div><div class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</div><div class="line">friend.sayName(); <span class="comment">// 'Nicholas'</span></div></pre></td></tr></table></figure>
<p>补充说明：</p>
<ul>
<li>返回的对象与构造函数或者与构造函数的原型属性之间没有关系，也就是说构造函数返回的对象与在构造函数外创建的对象没有什么不同。</li>
<li>不能依赖 <code>instanceof</code> 操作符来确定对象类型。</li>
<li>在能使用别的模式的情况下，不要使用该模式。</li>
</ul>
<h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>没有公共属性 | 其方法也不引用 <code>this</code> 的对象</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="comment">// 创建一个返回的对象</span></div><div class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  <span class="comment">// 可以在这里定义私有变量和函数</span></div><div class="line">  </div><div class="line">  <span class="comment">// 添加方法</span></div><div class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</div><div class="line">friend.sayName(); <span class="comment">// 'Nicholas'</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;注意：&lt;/em&gt; 本文来自阅读《JavaScript高级程序设计（第三版）》的笔记2或者也可以称作是书摘吧👾&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://blog.pikbug.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习" scheme="http://blog.pikbug.me/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="JavaScript" scheme="http://blog.pikbug.me/tags/JavaScript/"/>
    
      <category term="JavaScript高级程序设计（第三版）" scheme="http://blog.pikbug.me/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>Hexo个人博客搭建遇到的问题1</title>
    <link href="http://blog.pikbug.me/2017/04/06/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%981/"/>
    <id>http://blog.pikbug.me/2017/04/06/Hexo个人博客搭建遇到的问题1/</id>
    <published>2017-04-06T09:49:34.000Z</published>
    <updated>2017-04-06T10:52:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><ul>
<li>如图1、2</li>
</ul>
<p><img src="/2017/04/06/Hexo个人博客搭建遇到的问题1/QQ20170406-172817@2x.png" alt="1"><br><a id="more"></a><br><img src="/2017/04/06/Hexo个人博客搭建遇到的问题1/QQ20170406-173821@2x.png" alt="2"></p>
<p>对比可知，在<strong>发表于</strong>、<strong>更新于</strong>、<strong>分类于</strong>、<strong>阅读</strong>前边加了一些提示的icon。</p>
<ul>
<li><strong>分析问题</strong></li>
</ul>
<p>一开始我以为存在的问题是我的next主题没有配置好，也就是next目录下的 <code>_config.yml</code> 没配置好，百度、谷歌了好久，没找到答案。<br>后来就去页面看那个icon属于哪一个class，无意之间想去看看class的css文件终于发现了问题所在</p>
<ul>
<li><strong>如图3</strong></li>
</ul>
<p><img src="/2017/04/06/Hexo个人博客搭建遇到的问题1/next配置问题.png" alt="3"></p>
<ul>
<li>找到问题所在</li>
</ul>
<p>一开始图中的display属性是 <code>none</code> 。</p>
<ul>
<li><strong>最后</strong></li>
</ul>
<p>每次解决问题都是在想放弃的时候，感觉很平淡。QAQ</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题&quot;&gt;&lt;/a&gt;遇到的问题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;如图1、2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/2017/04/06/Hexo个人博客搭建遇到的问题1/QQ20170406-172817@2x.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="个人博客" scheme="http://blog.pikbug.me/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="个人博客" scheme="http://blog.pikbug.me/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>博客更新日志</title>
    <link href="http://blog.pikbug.me/2017/04/06/web-logs/"/>
    <id>http://blog.pikbug.me/2017/04/06/web-logs/</id>
    <published>2017-04-06T03:57:42.000Z</published>
    <updated>2017-04-07T10:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2016-11-21-更新内容："><a href="#2016-11-21-更新内容：" class="headerlink" title="2016-11-21 更新内容："></a>2016-11-21 更新内容：</h1><h2 id="完成主要的框架工作"><a href="#完成主要的框架工作" class="headerlink" title="完成主要的框架工作"></a>完成主要的框架工作</h2><blockquote>
<ul>
<li>熟悉Hexo</li>
<li>GitHub创建仓库、初始化项目</li>
<li>选取并且确定了Next主题</li>
<li><del>绑定域名blog.pikbug.me</del></li>
<li>新增一篇测试文章<a id="more"></a></li>
</ul>
</blockquote>
<h1 id="2017-02-18-更新内容："><a href="#2017-02-18-更新内容：" class="headerlink" title="2017-02-18 更新内容："></a>2017-02-18 更新内容：</h1><h2 id="主要完成了Next主题的配置工作"><a href="#主要完成了Next主题的配置工作" class="headerlink" title="主要完成了Next主题的配置工作"></a>主要完成了Next主题的配置工作</h2><blockquote>
<ul>
<li>添加「标签」页面</li>
<li>添加「分类」页面</li>
<li>增加404页面</li>
<li><del>增加多说评论</del></li>
<li><del>增加多说分享</del></li>
<li><del>增加cnzz统计</del></li>
<li>增加Algolia搜索功能（未成功奏效）</li>
<li>配置侧边栏的签名</li>
<li>新增一篇测试文章《&lt;暗时间&gt;书摘》</li>
<li>配置RSS</li>
</ul>
</blockquote>
<h1 id="2017-04-06-更新内容："><a href="#2017-04-06-更新内容：" class="headerlink" title="2017-04-06 更新内容："></a>2017-04-06 更新内容：</h1><h2 id="进一步完成主题配置-使功能正常使用"><a href="#进一步完成主题配置-使功能正常使用" class="headerlink" title="进一步完成主题配置 使功能正常使用"></a>进一步完成主题配置 使功能正常使用</h2><blockquote>
<ul>
<li>配置header 确定「首页」、「关于」、「归档」、「标签」、「搜索」</li>
<li>配置Algolia搜索功能，成功运行</li>
<li>增加谷歌统计功能</li>
<li>增加网易云跟帖功能，替代多说评论功能</li>
<li>增加JiaThis分享功能，替代多说分享功能</li>
<li>增加侧边栏版权说明</li>
<li>增加侧边栏社交链接</li>
<li>增加侧边栏友情链接</li>
<li>取消cnzz统计功能</li>
<li>增加阅读次数统计LeanCloud</li>
<li>编辑了footer 样式修改</li>
<li>更换域名解析 将域名解析由 <del><code>blog.pikbug.me</code></del> 改为 <code>pikbug.me</code><br>  <em><em>注意：</em></em> <ol>
<li>更改域名解析之前前要将 <code>source/</code> 的 <code>CNAME</code> 文件中解析到的地址改成你要解析到的地址 也就是 <code>pikbug.me</code></li>
<li>不知道到底要不要将 <code>blog</code> 下的 <code>.deploy_git</code> 删除掉在进行 如下操作，我是删掉了该目录</li>
<li>首先执行 <code>hexo algolia</code> 命令，刷新索引，当algolia网站的 <code>Indices</code> 页面显示如图所示<br><img src="/2017/04/06/web-logs/algolia-update-indexes.png" alt="png"><br>说明操作成功</li>
<li>再执行 <code>hexo g -d</code> 命令就可以生成静态博客并推送到GitHub了</li>
</ol>
</li>
<li>增加 <strong>发布于</strong>、<strong>更新于</strong>等多个标签前的icon 详情请看 <a href="http://pikbug.me/2017/04/06/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%981/" target="_blank" rel="external">这篇文章</a></li>
</ul>
</blockquote>
<h1 id="2017-04-07-更新内容："><a href="#2017-04-07-更新内容：" class="headerlink" title="2017-04-07 更新内容："></a>2017-04-07 更新内容：</h1><h2 id="进一步完成主题配置-完善网页显示"><a href="#进一步完成主题配置-完善网页显示" class="headerlink" title="进一步完成主题配置 完善网页显示"></a>进一步完成主题配置 完善网页显示</h2><blockquote>
<ul>
<li>增加版权声明 如图：<br><img src="/2017/04/06/web-logs/creative-commons.png" alt="creative-commons"></li>
<li>修改了一个菜单的icon 如图</li>
<li>将鼠标滑过标题链接时的显示颜色由黑色改为绿色<br><img src="/2017/04/06/web-logs/2017-04-07-update.png" alt="2017-04-07-update"></li>
<li>将网站的头像（avator.png）有正方形改为圆形</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2016-11-21-更新内容：&quot;&gt;&lt;a href=&quot;#2016-11-21-更新内容：&quot; class=&quot;headerlink&quot; title=&quot;2016-11-21 更新内容：&quot;&gt;&lt;/a&gt;2016-11-21 更新内容：&lt;/h1&gt;&lt;h2 id=&quot;完成主要的框架工作&quot;&gt;&lt;a href=&quot;#完成主要的框架工作&quot; class=&quot;headerlink&quot; title=&quot;完成主要的框架工作&quot;&gt;&lt;/a&gt;完成主要的框架工作&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;熟悉Hexo&lt;/li&gt;
&lt;li&gt;GitHub创建仓库、初始化项目&lt;/li&gt;
&lt;li&gt;选取并且确定了Next主题&lt;/li&gt;
&lt;li&gt;&lt;del&gt;绑定域名blog.pikbug.me&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;新增一篇测试文章&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="个人博客" scheme="http://blog.pikbug.me/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="个人博客" scheme="http://blog.pikbug.me/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="web-logs" scheme="http://blog.pikbug.me/tags/web-logs/"/>
    
  </entry>
  
  <entry>
    <title>《暗时间》书摘</title>
    <link href="http://blog.pikbug.me/2017/02/18/%E6%B5%8B%E8%AF%95/"/>
    <id>http://blog.pikbug.me/2017/02/18/测试/</id>
    <published>2017-02-18T08:10:25.000Z</published>
    <updated>2017-04-06T06:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识结构"><a href="#知识结构" class="headerlink" title="知识结构"></a>知识结构</h1><p>1.抓住不变量。<br>1️⃣底层知识：英语以及编程的语法知识等<br>2️⃣工具<br>3️⃣要熟悉自己的工具 熟练运用 熟悉运用<br><a id="more"></a></p>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>本质：学习新知识的带着第三只眼睛判断哪些知识是变量，或者不易变量，是否可以在用的时候查手册即可。<br>🤔补充：学习新知识的时候：⚡︎本质是什么；第一原则是什么；改制时的（体系或者层次）结构是什么。<br>😀现在是一个信息泛滥的时代，→需要学会在浩瀚的信息中选择我们需要的信息；→避免被不好的信息左右我们的大脑。<br>习惯的养成<br>〶江山易改，本性难移。<br>我们评价一个信念的标准是satisficing原则，即足够，能行就好。<br>🙃可以改变习惯<br>1️⃣认识到习惯的改变不是一两天实现的，承认它的难度；<br>2️⃣真想改掉自己习惯，注意观察自己的习惯，把要克服的习惯的那个自我当做自己的一个孩子，然后去打败他；<br>🐷我喜欢这句话：知难而不退，值得做的事情几乎总是如此😀。<br>我在南大的七年<br>父亲告诉我的第二件事情是：遇到问题，找书去就行。<br>🤔改变一生的两个习惯：1️⃣学习东西不觉得是累，自得其乐。2️⃣学习新东西的方法。<br>🐶与父母共同的性格：遇到麻烦和困难的事情从不放弃。<br>🐱我在CSDN上开了博客，开始学习C++和编程中的一些总结。这个博客一直写到离开南大，伴随了我真个七年的学习和成长，回过头去看像时光机一样，能够看到一路过来我都关注了什么是怎么想的，以及对一些事情的看法是怎么变化的。这些东西如果不记录下来，会逐渐忘记，也就无法参照过去的自己，对未来提供更好的借鉴了。所以我一直把记录当做一个很重要的工具。另外我也同感这个博客认识了很多朋友，得到了很多的帮助。</p>
<h1 id="逃出你的肖申克（一）"><a href="#逃出你的肖申克（一）" class="headerlink" title="逃出你的肖申克（一）"></a>逃出你的肖申克（一）</h1><p>为什么我们常说很多时候一定邀请神经理之后才明白<br>1️⃣切身体会。亲身经理负面事件带来的情绪反应比看着或者听说别人遭受一个同样的时间感受到的强烈的多，形成的情绪记忆更持久。心理学上，自己无法从强度上真正感同身受别人的痛苦。<br>2️⃣别人口中的故事。别人口中的故事也许只是他们的想法，你自己亲身经历同样的事情也许完全有事另外一种想法。<br>3️⃣为什么。很难说服自己A选项优于B选项，直到最终自己在某一条路上撞了南墙才肯死心。<br>4️⃣世界是复杂的。各种错综复杂的因素和响应下，用单一因果来解释事件几乎总是不恰当的。<br>5️⃣未来是不确定的。外界因素是不可控的，我们能做得到只是做好头脑准备，尽量不错失机会。成功并不是仅仅取决于个人因素。个人因素往往只是成功的一个既非充分又非必要的条件，所谓谋事在人成事在天；但无需悲观，因为毫无疑问的是，改变个人因素的却能够增加成功的几率。<br>6️⃣别人的道理，自己的事情。<br>🐹解决问题的两步思维步骤：①根据问题从记忆系统中提取以往成功的方案；②多多思考观察自己，抽象其本质。<br>7️⃣认知失调与自我辩护<br>8️⃣失败即成功<br>9️⃣情绪对照<br>🔟天性 ①一个理性大脑②一个原始大脑。 如果你总是感到满足的话，就不会去进取，在一个残酷的优胜劣汰的环境中，你的这种不思进取的基因就会被淘汰。<br>我们常常需要用理性的声音去说服内心的原始人。<br>十一 习惯</p>
<p>亲身经历了就一定明白吗<br>⒈很傻很天真的条件反射<br>①没有得到好的结果并不代表你的过程就错了<br>②结果正确也不代表方法就一定正确<br>③客观做法：而不是看着单次的结果 —— 因为再好的过程也可能会偶尔失利，但从长远统计来看，好的过程总体上必然导致好的结果（《别做正常的傻瓜》第12章：“抓住老鼠的一定是好猫吗 —— 结果偏见”对此介绍）<br>⒉认知偏见<br>推荐书籍《How we know what isn’t so》 其中包含一些经典的谬误<br>⒊情绪系统<br>①日常的决策与判断强烈地依赖与情绪系统的输出<br>②始终别忘记情绪系统只是一个比较粗糙的判断与决策系统，并且它很多时候是为了适应远古时代而非现代社会的。</p>
<p>不需要亲历也能够明白——理性的力量<br>①我满大多是让事实替代我们进行思考和推理，我们从失败当中获得信息。<br>②人最强大的能力是社会学习：普通人从自己的错误中学习，聪明人从别人的错误中学习。<br>③人最强大的另外一个能力则是：归纳和判断。<br>∑我们再打澳洲越走越远，在现实中越走越稳。我们在大脑中失败的次数越多，在现实中失败的次数就会越少。<br>我的感受：多思考！</p>
<h1 id="逃出你的肖申克（二）"><a href="#逃出你的肖申克（二）" class="headerlink" title="逃出你的肖申克（二）"></a>逃出你的肖申克（二）</h1><p>①这些先验假设并不蕴藏咋图片中，而是在我们长期的生活中无意识统计出来的，或者干脆就是漫长的进化过程中帅选出来的有价值的先验假设——正如婴儿天生吃奶起就懂得吮吸一样。<br>②有时候打破偏见的唯一途径就是开阔视野，多积累知识，以及和具有不同知识背景的人讨论。—— 当你知道越多你就懂得越少<br>③需要与不同背景的人进行讨论，弥补个人经验知识的局限性导致的偏差，并时常使用以下两句话来提醒自己保持Open Mind：这只是一种可能；<br>想不出其他解释不代表就不存在其他的解释。</p>
<h1 id="逃出你的肖申克（三）"><a href="#逃出你的肖申克（三）" class="headerlink" title="逃出你的肖申克（三）"></a>逃出你的肖申克（三）</h1><p>——遇见20万年前的自己<br>①世界上最痛苦的事情不是和别人作斗争，而是和自己作斗争。<br>②大脑决策：直觉进行决策；理性分析<br>③emotion和motion在词源上是同源词。人们了解到了情绪和动力的关系<br>④我们对于未来的惩罚和收益估计不足，更倾向于就眼下的损益进行决策，会导致我们目光短浅。<br>⑤很多时候我们只是生活在信息社会的远古人。</p>
<h1 id="逃出你的肖申克（四）"><a href="#逃出你的肖申克（四）" class="headerlink" title="逃出你的肖申克（四）"></a>逃出你的肖申克（四）</h1><p>1⃣️当你觉得自己想的很有道理，无懈可击，客观公正的时候，你是否真正像你认为的那样客观公正呢？Artemus Ward曾经说过：“并不是那些我们不知道的事情让我们陷入麻烦，而是那些我们认为自己知道，却实际上是错误的知识，让我们陷入麻烦。”客观意味着承认存在未知信息的可能性，理性意味着能够从对立面的视角去看问题和思考。<br>2⃣️学会质疑自己<br>3⃣️与其让别人指出自己的错误，不如自己试着去发现自己的错误。<br>4⃣️大脑符合用进废退的原理，越经常使用的区域越发达。<br>5⃣️习惯之所以难以改变改变，就是因为习惯是自我巩固的——越用越强，越强越用。<br>6⃣️能够改变既有的习惯，依靠的不是自制力，而是知识。<br>7⃣️分散注意力<br>书写时为了更好地思考<br>书写的好处：<br>1⃣️书写是对思维的备忘。<br>2⃣️书写是对思维的缓存。<br>3⃣️书写是与自己的对话<br>4⃣️书写是与别人的交流<br>5⃣️有时候，语言自己也会思考</p>
<h1 id="为什么你从现在开始就应该写博客"><a href="#为什么你从现在开始就应该写博客" class="headerlink" title="# 为什么你从现在开始就应该写博客"></a># 为什么你从现在开始就应该写博客</h1><p>🙃写一个博客有很多的好处，却没有任何明显的坏处<br>🐹用博客的形式来记录下你有价值的思考，会带来很多好处，却没有很明显的坏处。<br>1⃣️能够交到很多志同道合的朋友<br>2⃣️书写是为了更好地思考<br>3⃣️“教”是最好的“学”。一旦你把自己潜意识里面的东西从幕后拉出来，你就有了面对并反思它们的可能性，而不是任它们的可能性，而不是任它们在幕后阴险地左右你的思维。去教一个完全不懂的人，则是一个最强大和彻底的反思途径<br>4⃣️讨论是绝佳的反思比较你和别人观念之间的差别，进一步讨论中她们就会不断迫使对方拿出更深层滋的理由。<br>5⃣️激励你去持续学习和思考。<br>6⃣️学会持之以恒地做一件事情<br>7⃣️一个长期的价值博客是一份很好的简历。<br>怎样做到长期写一个价值博客<br>因为你在思考和总结从而必须写下里，写博客也就变成了副产品。<br>让你自己成为一个持续学习和思考的人，并只写你真正思考和总结的产物，其他的一切都会随之而来。——只做你最感兴趣的事情，钱会随之而来。<br>可能出现的问题以及怎样应对<br>意志力很大程度上来源于正确的方法，而非天生。<br>1⃣️担心别人认为没有价值。<br>2⃣️担心想法太幼稚或有漏洞等等被别人笑话。<br>3⃣️得不到鼓励 overnight success takes a long time（一夜成名需要很长时间）<br>4⃣️写不出来  能够吧问题长时间停留在潜意识中是一种技能，能够嗲来很大的好处，停留越久你越琢磨得透彻，比别人看到的就越多。<br>我不想与我不能<br>自利归因 就是对一件事情发生的原因归结为对自己有利的那种情况。——不能给自己难堪，不能让自己下不来台。功劳都给自己买责任都给别人担。<br>自利归因表现形式：注意力等于现实。即，观察者偏见所起的作用就像一个过滤器——唯心主义人择原理的话就是——世界是这个样子就因为我看到他是这个样子的。</p>
<p>遇到问题为什么应该自己动手<br>知其所以然<br>🐹我们要的不是相对论，而是诞生相对论的那个大脑。我们要的不是金蛋，而是下金蛋的那只鸡。<br>思考问题的两种思维方式：<br>1⃣️联想。此方式不是最佳的思维方式。充满了错误的可能。<br>2⃣️演绎&amp;归纳。比“联想”的思维方式好一点。<br>人类解决问题的两大思维方式实际上都有很大的试错成分（探索）。<br>😎当我们遇到问题时：<br>1⃣思维的漫长繁杂的过程已经在大脑里面淡化的差不多了；<br>2⃣思维过程对我们的空气和水，而“鱼是最后一个感觉到水的”，我们感觉不到思维法则本身的存在，我们只是不知不觉运用它。<br>3⃣我们的目标是问题的解，过程是过程。目的是目的。<br>4⃣感到介绍思维过程是不相干的。不能放弃对求解过程。<br>思维过程的极其重要的价值：<br>1.内隐化<br>2.跨情景运用。思维法则也是记忆。<br>3.对问题解的更多记忆提取线索<br>4.包含了多得多的知识。<br>5.重在分析推理，而不是联想。<br>6.寻找该算法的原始出处。<br>7.原始出处气势未必就都推心置腹和你讲的那么到位。<br>8.不仅仅学习别人的思路，整理自己的思路也是极其重要的。<br>为什么有必要知其所以然</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;知识结构&quot;&gt;&lt;a href=&quot;#知识结构&quot; class=&quot;headerlink&quot; title=&quot;知识结构&quot;&gt;&lt;/a&gt;知识结构&lt;/h1&gt;&lt;p&gt;1.抓住不变量。&lt;br&gt;1️⃣底层知识：英语以及编程的语法知识等&lt;br&gt;2️⃣工具&lt;br&gt;3️⃣要熟悉自己的工具 熟练运用 熟悉运用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.pikbug.me/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="测试" scheme="http://blog.pikbug.me/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="个人博客" scheme="http://blog.pikbug.me/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Hello Blog</title>
    <link href="http://blog.pikbug.me/2016/11/21/Hello%20World/"/>
    <id>http://blog.pikbug.me/2016/11/21/Hello World/</id>
    <published>2016-11-20T16:10:25.000Z</published>
    <updated>2017-04-06T06:28:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个新的开始，花了一下午外加一晚上的时间，差不多趟了所有的坑。<br><a id="more"></a><br>终于搭好了个人博客。接下来的日子，就需要慢慢来优化了！大家拭目以待！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个新的开始，花了一下午外加一晚上的时间，差不多趟了所有的坑。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="http://blog.pikbug.me/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="日记" scheme="http://blog.pikbug.me/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="测试" scheme="http://blog.pikbug.me/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="个人博客" scheme="http://blog.pikbug.me/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
