<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[git学习笔记✔️02]]></title>
      <url>http://blog.pikbug.me/2017/04/13/learn-git-02/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<p><strong>注意：</strong> 本文是根据 <a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的官方网站的Git教程</a> 的学习笔记</p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[git学习笔记✔️01]]></title>
      <url>http://blog.pikbug.me/2017/04/12/learn-git/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<blockquote>
<p><strong>注意：</strong> 本文是根据 <a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的官方网站的Git教程</a> 的学习笔记</p>
</blockquote>
<h1 id="『第一节课』创建版本库"><a href="#『第一节课』创建版本库" class="headerlink" title="『第一节课』创建版本库"></a>『第一节课』创建版本库</h1><h2 id="初始化一个Git仓库"><a href="#初始化一个Git仓库" class="headerlink" title="初始化一个Git仓库"></a>初始化一个Git仓库</h2><ol>
<li>找一个合适的地方</li>
<li>创建一个文件夹 <code>mkdir learning-git</code></li>
<li>进入该文件夹 <code>cd</code></li>
<li><p>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库 <a id="more"></a></p>
 <figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">☁  learning-git  git init</div><div class="line">Initialized empty Git repository <span class="keyword">in</span> <span class="regexp">/Users/</span>MiG<span class="regexp">/Documents/</span>Learning<span class="regexp">/Git/</span>learning-git<span class="regexp">/.git/</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 此时仓库就创建好了，文件夹下会多了一个名为 <code>.git</code> 的文件夹📂 </p>
</blockquote>
</li>
<li><p>添加一个 <code>README.md</code> 文件 </p>
</li>
<li><p>用 <code>git add README.md</code> 命令将 <code>README.md</code> 将该文件添加到仓库</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">☁  learning-git [master] ⚡ git <span class="keyword">commit</span> -m <span class="string">"add README.md"</span></div><div class="line">[<span class="keyword">master</span> (root-<span class="keyword">commit</span>) a75f826] <span class="keyword">add</span> README.md</div><div class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">2</span> insertions(+)</div><div class="line"> <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> README.md</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><strong>注意：</strong> <code>-m</code> 后面输入的是本次提交的说明</p>
</blockquote>
<h1 id="『第二节课』查看修改信息"><a href="#『第二节课』查看修改信息" class="headerlink" title="『第二节课』查看修改信息"></a>『第二节课』查看修改信息</h1><h2 id="可以通过-git-status-命令查看仓库的状态："><a href="#可以通过-git-status-命令查看仓库的状态：" class="headerlink" title="可以通过 git status 命令查看仓库的状态："></a>可以通过 <code>git status</code> 命令查看仓库的状态：</h2><p>当我们没有进行修改的时候 输入 <code>git status</code> 可以看到如下输出</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">☁  learning-git [<span class="literal">master</span>] git status</div><div class="line">On branch <span class="keyword">master</span></div><div class="line"><span class="title">nothing</span> to commit, working tree clean</div></pre></td></tr></table></figure>
<h2 id="当我们进行一些修改之后"><a href="#当我们进行一些修改之后" class="headerlink" title="当我们进行一些修改之后:"></a>当我们进行一些修改之后:</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">☁  learning-git [<span class="literal">master</span>] ⚡ git status</div><div class="line">On branch <span class="keyword">master</span></div><div class="line"><span class="title">Changes</span> to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">	modified:   README.md</div></pre></td></tr></table></figure>
<h2 id="当此时输入-git-diff-README-md-会输出如下信息："><a href="#当此时输入-git-diff-README-md-会输出如下信息：" class="headerlink" title="当此时输入 git diff README.md 会输出如下信息："></a>当此时输入 <code>git diff README.md</code> 会输出如下信息：</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">diff --git a/README.md b/README.md</div><div class="line">index 6276f73..6abd600 100644</div><div class="line"><span class="comment">--- a/README.md</span></div><div class="line"><span class="comment">+++ b/README.md</span></div><div class="line"><span class="meta">@@ -1,4 +1,4 @@</span></div><div class="line"> Git is a version control system.</div><div class="line"> Git is free software.</div><div class="line"><span class="deletion">-</span></div><div class="line"><span class="addition">+Git is awosome.</span></div><div class="line"> Git is create by Linus.</div></pre></td></tr></table></figure>
<h2 id="此时，输入-git-status-命令查看仓库的状态："><a href="#此时，输入-git-status-命令查看仓库的状态：" class="headerlink" title="此时，输入 git status 命令查看仓库的状态："></a>此时，输入 <code>git status</code> 命令查看仓库的状态：</h2><p>会输出如下信息：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</div><div class="line"></div><div class="line">	modified:   README.md</div><div class="line"></div><div class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</div><div class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</div><div class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</div><div class="line"></div><div class="line">	modified:   README.md</div></pre></td></tr></table></figure></p>
<p>提示信息没有提交</p>
<h2 id="接下来，输入-git-add-README-md："><a href="#接下来，输入-git-add-README-md：" class="headerlink" title="接下来，输入 git add README.md："></a>接下来，输入 <code>git add README.md</code>：</h2><p>没有提示</p>
<blockquote>
<p>补充： <code>git add</code> 的作用是将提交的文件的信息添加到索引库中</p>
</blockquote>
<h2 id="然后，-输入-git-status："><a href="#然后，-输入-git-status：" class="headerlink" title="然后， 输入 git status："></a>然后， 输入 <code>git status</code>：</h2><p>输出信息如下：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">☁  learning-git [<span class="literal">master</span>] ⚡ git status</div><div class="line">On branch <span class="keyword">master</span></div><div class="line"><span class="title">Changes</span> to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">	modified:   README.md</div></pre></td></tr></table></figure></p>
<h2 id="然后，-输入-git-commit-m-quot-modify-README-md-quot"><a href="#然后，-输入-git-commit-m-quot-modify-README-md-quot" class="headerlink" title="然后， 输入 git commit -m &quot;modify README.md&quot;"></a>然后， 输入 <code>git commit -m &quot;modify README.md&quot;</code></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">☁  learning-git [master] ⚡ git <span class="keyword">commit</span> -m <span class="string">"modify README.md"</span></div><div class="line">[<span class="keyword">master</span> <span class="number">48</span>a04b0] <span class="keyword">modify</span> README.md</div><div class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">2</span> insertions(+)</div></pre></td></tr></table></figure>
<p>最后，输入最后一次 <code>git status</code>：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">☁  learning-git [<span class="literal">master</span>] git status</div><div class="line">On branch <span class="keyword">master</span></div><div class="line"><span class="title">nothing</span> to commit, working tree clean</div></pre></td></tr></table></figure>
<h2 id="本节课的补充："><a href="#本节课的补充：" class="headerlink" title="本节课的补充："></a>本节课的补充：</h2><ul>
<li><p><code>git add</code> 是将修改内容或者新文件添加到本地缓存区</p>
</li>
<li><p>再用 <code>git commit</code> 将本地缓冲区的内容提交到本地仓库</p>
</li>
<li><p><code>git add</code> 的各种区别:</p>
<p>  <code>git add -A  // 添加所有改动</code></p>
<p>  <code>git add *     // 添加新建文件和修改，但是不包括删除</code></p>
<p>  <code>git add .    // 添加新建文件和修改，但是不包括删除</code></p>
<p>  <code>git add -u   // 添加修改和删除，但是不包括新建文件</code></p>
</li>
<li><p>在 <code>commit</code> 前撤销 <code>add</code>:</p>
<p>  <code>git reset &lt;file&gt; // 撤销提交单独文件</code></p>
<p>  <code>git reset        // unstage all due changes</code><br>  <code>add/commit</code> 前撤销对文件的修改:</p>
<p>  <code>git checkout -- README.md  // 注意, add添加后(同commit提交后)就无法通过这种方式撤销修改</code></p>
</li>
</ul>
<h1 id="『第三节课』版本退回"><a href="#『第三节课』版本退回" class="headerlink" title="『第三节课』版本退回"></a>『第三节课』版本退回</h1><h2 id="可以通过-git-log-查看提交历史"><a href="#可以通过-git-log-查看提交历史" class="headerlink" title="可以通过 git log 查看提交历史"></a>可以通过 <code>git log</code> 查看提交历史</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">commit <span class="number">48</span>a04b0f26cc80ed8ad000b9b64675142f6d9bcd</div><div class="line"><span class="symbol">Author:</span> GiHccTpD &lt;yanrancanfei<span class="subst">@163</span>.com&gt;</div><div class="line"><span class="symbol">Date:</span>   Wed Apr <span class="number">12</span> <span class="number">12</span>:<span class="number">08</span>:<span class="number">03</span> <span class="number">2017</span> +<span class="number">0800</span></div><div class="line"></div><div class="line">    modify README.md</div><div class="line"></div><div class="line">commit a75f82682054606bdcec5c7f94590fff2d1de35c</div><div class="line"><span class="symbol">Author:</span> GiHccTpD &lt;yanrancanfei<span class="subst">@163</span>.com&gt;</div><div class="line"><span class="symbol">Date:</span>   Wed Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">18</span>:<span class="number">59</span> <span class="number">2017</span> +<span class="number">0800</span></div><div class="line"></div><div class="line">    <span class="keyword">add</span> README.md</div></pre></td></tr></table></figure>
<h2 id="还可以通过-git-log-pretty-oneline-格式化输出提交信息："><a href="#还可以通过-git-log-pretty-oneline-格式化输出提交信息：" class="headerlink" title="还可以通过 git log --pretty=oneline 格式化输出提交信息："></a>还可以通过 <code>git log --pretty=oneline</code> 格式化输出提交信息：</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">48</span>a<span class="number">04</span>b<span class="number">0</span>f<span class="number">26</span><span class="keyword">cc</span><span class="number">80</span>ed<span class="number">8</span>ad<span class="number">000</span>b<span class="number">9</span>b<span class="number">64675142</span>f<span class="number">6</span>d<span class="number">9</span>bcd modify README.md</div><div class="line">a<span class="number">75</span>f<span class="number">82682054606</span>bdcec<span class="number">5</span><span class="keyword">c</span><span class="number">7</span>f<span class="number">94590</span>fff<span class="number">2</span>d<span class="number">1</span>de<span class="number">35</span><span class="keyword">c</span> <span class="keyword">add</span> README.md</div></pre></td></tr></table></figure>
<p><code>48a04b0f26cc80ed8ad000b9b64675142f6d9bcd</code> 是 <code>commit id</code> 版本号,不同于 <code>SVN</code> 的数字版本号，<code>SHA1</code> 计算出来的一个非常大的数字，用十六进制表示。</p>
<h2 id="可以通过-git-reset-hard-HEAD-命令退回上一个版本"><a href="#可以通过-git-reset-hard-HEAD-命令退回上一个版本" class="headerlink" title="可以通过 git reset --hard HEAD^ 命令退回上一个版本:"></a>可以通过 <code>git reset --hard HEAD^</code> 命令退回上一个版本:</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">☁  learning-git [master] git <span class="keyword">reset</span> <span class="comment">--hard HEAD^</span></div><div class="line"><span class="keyword">HEAD</span> <span class="keyword">is</span> <span class="keyword">now</span> <span class="keyword">at</span> a75f826 <span class="keyword">add</span> README.md</div></pre></td></tr></table></figure>
<blockquote>
<p>此时，通过 <code>git log --pretty=oneline</code> 可以看到输出的是如下的信息：  <code>a75f82682054606bdcec5c7f94590fff2d1de35c add README.md</code></p>
</blockquote>
<h2 id="也可以通过-git-reset-hard-commit-id-来实现要退回的版本"><a href="#也可以通过-git-reset-hard-commit-id-来实现要退回的版本" class="headerlink" title="也可以通过 git reset --hard commit_id 来实现要退回的版本"></a>也可以通过 <code>git reset --hard commit_id</code> 来实现要退回的版本</h2><h2 id="命令-git-reflog-用来记录你的每一次命令"><a href="#命令-git-reflog-用来记录你的每一次命令" class="headerlink" title="命令 git reflog 用来记录你的每一次命令"></a>命令 <code>git reflog</code> 用来记录你的每一次命令</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a75f826</span> <span class="selector-tag">HEAD</span>@&#123;0&#125;: <span class="selector-tag">reset</span>: <span class="selector-tag">moving</span> <span class="selector-tag">to</span> <span class="selector-tag">HEAD</span>^</div><div class="line">48<span class="selector-tag">a04b0</span> <span class="selector-tag">HEAD</span>@&#123;1&#125;: <span class="selector-tag">commit</span>: <span class="selector-tag">modify</span> <span class="selector-tag">README</span><span class="selector-class">.md</span></div><div class="line"><span class="selector-tag">a75f826</span> <span class="selector-tag">HEAD</span>@&#123;2&#125;: <span class="selector-tag">commit</span> (<span class="selector-tag">initial</span>): <span class="selector-tag">add</span> <span class="selector-tag">README</span><span class="selector-class">.md</span></div><div class="line">(<span class="selector-tag">END</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>补充：</strong> Git在内部有个指向当前版本的 <code>HEAD</code> 指针，它指向的版本就是当前版本。</p>
</blockquote>
<h1 id="『第四节课』工作区与暂存区"><a href="#『第四节课』工作区与暂存区" class="headerlink" title="『第四节课』工作区与暂存区"></a>『第四节课』工作区与暂存区</h1><h2 id="文件夹📂-learning-git-就是一个工作区"><a href="#文件夹📂-learning-git-就是一个工作区" class="headerlink" title="文件夹📂 learning-git 就是一个工作区"></a>文件夹📂 <code>learning-git</code> 就是一个工作区</h2><h2 id="版本库（Repository）-隐藏的文件夹📂-git-就是一个版本库"><a href="#版本库（Repository）-隐藏的文件夹📂-git-就是一个版本库" class="headerlink" title="版本库（Repository） 隐藏的文件夹📂 .git 就是一个版本库"></a>版本库（Repository） 隐藏的文件夹📂 <code>.git</code> 就是一个版本库</h2><p>如图所示：</p>
<p><img src="/2017/04/12/learn-git/Repository.png" alt="Repository"><br>图片来自: <a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013745374151782eb658c5a5ca454eaa451661275886c6000" target="_blank" rel="external">廖雪峰的官方网站</a></p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<ul>
<li>第一步是用 <code>git add</code> 把文件添加进去，实际上就是把文件修改添加到暂存区；</li>
<li>第二步是用 <code>git commit</code> 提交更改，实际上就是把暂存区的所有内容提交到当前分支。</li>
</ul>
<h2 id="操作演示"><a href="#操作演示" class="headerlink" title="操作演示"></a>操作演示</h2><p><img src="/2017/04/12/learn-git/Repository01.png" alt="Repository01"></p>
<h1 id="『第五节课』Git管理的是修改"><a href="#『第五节课』Git管理的是修改" class="headerlink" title="『第五节课』Git管理的是修改"></a>『第五节课』Git管理的是修改</h1><blockquote>
<p><strong>注意：</strong> 因为Git跟踪并管理的是修改，而非文件。</p>
</blockquote>
<h1 id="『第六节课』撤销修改"><a href="#『第六节课』撤销修改" class="headerlink" title="『第六节课』撤销修改"></a>『第六节课』撤销修改</h1><h2 id="当没有提交到缓冲区时"><a href="#当没有提交到缓冲区时" class="headerlink" title="当没有提交到缓冲区时"></a>当没有提交到缓冲区时</h2><p>通过使用命令 <code>git checkout -- README.md</code>  把 <code>README.md</code> 文件在工作区的修改全部撤销</p>
<p>一种是<code>README.md</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>README.md</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<h2 id="操作演示："><a href="#操作演示：" class="headerlink" title="操作演示："></a>操作演示：</h2><p><img src="/2017/04/12/learn-git/checkout.png" alt="checkout"></p>
<blockquote>
<p>在 <code>git status</code> 之前有一次修改。</p>
</blockquote>
<h2 id="当将修改的文件提交到缓冲区的时候"><a href="#当将修改的文件提交到缓冲区的时候" class="headerlink" title="当将修改的文件提交到缓冲区的时候"></a>当将修改的文件提交到缓冲区的时候</h2><p>首先，修改下文件。</p>
<h3 id="用命令-git-reset-HEAD-README-md-可以把暂存区的修改撤销掉（unstage），重新放回工作区"><a href="#用命令-git-reset-HEAD-README-md-可以把暂存区的修改撤销掉（unstage），重新放回工作区" class="headerlink" title="用命令 git reset HEAD README.md 可以把暂存区的修改撤销掉（unstage），重新放回工作区"></a>用命令 <code>git reset HEAD README.md</code> 可以把暂存区的修改撤销掉（unstage），重新放回工作区</h3><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p>
<h2 id="接下来，还要-使用命令-git-checkout-README-md-来丢弃工作区的修改"><a href="#接下来，还要-使用命令-git-checkout-README-md-来丢弃工作区的修改" class="headerlink" title="# 接下来，还要 使用命令 git checkout -- README.md 来丢弃工作区的修改"></a># 接下来，还要 使用命令 <code>git checkout -- README.md</code> 来丢弃工作区的修改</h2><h3 id="操作演示：-1"><a href="#操作演示：-1" class="headerlink" title="操作演示："></a>操作演示：</h3><p><img src="/2017/04/12/learn-git/checkout02.png" alt="reset"></p>
<p>然后通过  <code>git checkout -- README.md</code>  丢弃工作区修改</p>
<p><img src="/2017/04/12/learn-git/checkout03.png" alt="reset"></p>
<h1 id="『第七节课』删除文件"><a href="#『第七节课』删除文件" class="headerlink" title="『第七节课』删除文件"></a>『第七节课』删除文件</h1><h2 id="首先添加一个文件-vim-test-del-md-，-再随便添加点内容。"><a href="#首先添加一个文件-vim-test-del-md-，-再随便添加点内容。" class="headerlink" title="首先添加一个文件 vim test_del.md ， 再随便添加点内容。"></a>首先添加一个文件 <code>vim test_del.md</code> ， 再随便添加点内容。</h2><p> 然后本地删除文件 <code>rm -rf test_del.md</code> 文件</p>
<p>输入 <code>git status</code> 可以查看现在的状态，在下面的操作演示图片里面</p>
<h2 id="当你也要将版本库中的文件删除的时候，就可以输入-git-rm-test-del-md-将其删除啦"><a href="#当你也要将版本库中的文件删除的时候，就可以输入-git-rm-test-del-md-将其删除啦" class="headerlink" title="当你也要将版本库中的文件删除的时候，就可以输入 git rm test_del.md 将其删除啦"></a>当你也要将版本库中的文件删除的时候，就可以输入 <code>git rm test_del.md</code> 将其删除啦</h2><h2 id="当你是操作失误的时候，-可以输入-git-checkout-test-del-md-将版本库中的文件拉取出来，覆盖本地的版本"><a href="#当你是操作失误的时候，-可以输入-git-checkout-test-del-md-将版本库中的文件拉取出来，覆盖本地的版本" class="headerlink" title="当你是操作失误的时候， 可以输入 git checkout --test_del.md 将版本库中的文件拉取出来，覆盖本地的版本"></a>当你是操作失误的时候， 可以输入 <code>git checkout --test_del.md</code> 将版本库中的文件拉取出来，覆盖本地的版本</h2><h2 id="操作代码"><a href="#操作代码" class="headerlink" title="操作代码"></a>操作代码</h2><p><img src="/2017/04/12/learn-git/del.png" alt="del"></p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十大经典排序算法]]></title>
      <url>http://blog.pikbug.me/2017/04/11/JS-Sorting-Algorithm/</url>
      <content type="html"><![CDATA[<h1 id="『转载』十大经典排序算法"><a href="#『转载』十大经典排序算法" class="headerlink" title="『转载』十大经典排序算法"></a>『转载』十大经典排序算法</h1><p><a href="https://sort.hust.cc/" target="_blank" rel="external">https://sort.hust.cc/</a></p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[创建对象的方式]]></title>
      <url>http://blog.pikbug.me/2017/04/09/JavaScript-ways-of-create-object/</url>
      <content type="html"><![CDATA[<blockquote>
<p><em>注意：</em> 本文来自阅读《JavaScript高级程序设计（第三版）》的笔记或者也可以称作是书摘吧👾</p>
</blockquote>
<a id="more"></a>
<h2 id="一般方式"><a href="#一般方式" class="headerlink" title="一般方式"></a>一般方式</h2><ul>
<li>构造函数</li>
<li>对象字面量</li>
</ul>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>这种模式抽象了创建具体对象的过程。如下例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    o.name =  name;</div><div class="line">    o.age = age;</div><div class="line">    o.job = job;</div><div class="line">    o.sayName = functioin () &#123;</div><div class="line">        alert (<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实例化两个类</span></div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'xixi'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">'waXaw'</span>, <span class="number">27</span>, <span class="string">'teacher'</span>);</div></pre></td></tr></table></figure>
<p>虽然解决了常见太多相似类的问题，但却没有解决对象识别的问题。</p>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>像 <code>Array</code> 和 <code>Object</code> 这样的原生构造函数，在运行时会自动创建执行环境，还可以自定义对象属性和方法。如下例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name =  name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = functioin () &#123;</div><div class="line">        alert (<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实例化两个类</span></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'xixi'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'waXaw'</span>, <span class="number">27</span>, <span class="string">'teacher'</span>);</div></pre></td></tr></table></figure>
<p>与之前的工厂模式对比可以有以下发现：</p>
<ul>
<li>没有显式地创建对象</li>
<li>直接将属性和方法赋给了 <code>this</code> 对象</li>
<li>没有 <code>return</code> 语句</li>
</ul>
<p><em>注意：</em> 构造函数应该以一个大写字母开头</p>
<p>实例化一个对象，要经过以下步骤：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋值给新对象（因此 <code>this</code> 就指向了这个新对象）</li>
<li>执行构造函数中的代码（为这个类对象添加属性）</li>
<li>返回对象</li>
</ol>
<p><code>person1</code> 和 <code>person2</code> 分别保存着 <code>Person</code> 类的一个不同的实例。 这个两个对象都有一个 <code>constructor</code> （构造函数）属性，该属性指向 <code>Person</code>。<br>创建自定义的构造函数意味着将来可以将它的实例为一种特定的类型，此处正是构造函数模式胜过工厂模式的地方。</p>
<p>构造函数是一种特殊的函数，他可以通过 <code>new</code> 操作符来调用。</p>
<h3 id="构造函数调用方式："><a href="#构造函数调用方式：" class="headerlink" title="构造函数调用方式："></a>构造函数调用方式：</h3><ul>
<li>1.当做构造函数使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'xixi'</span>, <span class="number">29</span>, <span class="string">'Software Engneer'</span>);</div><div class="line">person.sayName(); <span class="comment">//'xixi'</span></div></pre></td></tr></table></figure>
<ul>
<li>2.作为普通函数使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Person(<span class="string">'waXaw'</span>, <span class="number">24</span>, <span class="string">'Teacher'</span>);</div><div class="line"><span class="built_in">window</span>.sayName(); <span class="comment">//'waXaw'</span></div></pre></td></tr></table></figure>
<ul>
<li>3.在对象的另一个作用域中调用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">Person.call(o, <span class="string">'mig'</span>, <span class="number">23</span>, <span class="string">'CEO'</span>);</div><div class="line">o.sayName(); <span class="comment">//'mig'</span></div></pre></td></tr></table></figure>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>构造函数的方法 （即 <code>sayName</code> ）每次都要重新创建一遍。也就是说 <code>person1</code> 和 <code>person2</code> 的 <code>sayName</code> 不是同一个 <code>Function</code> 创建的。<br>可以通过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(person1.sayName === person2.sayName()); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><strong>解决方法：</strong><br>函数定义转移到构造函数的外部。如下例所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name =  name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName =sayName;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">functioin sayName() &#123;</div><div class="line">        alert (<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 实例化两个类</span></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'xixi'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'waXaw'</span>, <span class="number">27</span>, <span class="string">'Teacher'</span>);</div></pre></td></tr></table></figure>
<p><strong>新的问题：</strong></p>
<ul>
<li><code>sayName</code> 使得全局变量名不副实</li>
<li>自定义的引用类型没有了封装性可言</li>
</ul>
<h2 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h2><blockquote>
<p><strong>原型（ <code>prototype</code> ）属性：</strong></p>
<p>这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。<code>prototype</code> 就是通过构造函数而创建的那个对象实例的原型对象。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">'Nicholas'</span>;</div><div class="line">Person.prototype.age = <span class="number">29</span>;</div><div class="line">Person.prototype.job = <span class="string">'Software Engneer'</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line">person1.sayName(); <span class="comment">// 'Nicholas'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person2.sayName(); <span class="comment">// 'Nicholas'</span></div><div class="line"></div><div class="line">alert(person1.sayName === person2.sayName); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h3><p>当创建一个新函数的时候，就会创建一个 <code>prototype</code> 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象会自动获得一个  <code>constractor</code> （构造函数）属性，这个属性包含一个指向 <code>prototype</code> 属性所在函数的指针。如图所示，<code>Person.prototype.constructor</code> 指向 <code>Person</code> 。也就是说，可以通过这个构造函数为原型对象添加其他属性和方法。 </p>
<p><a href="JavaScript-ways-of-create-object/prototype.png">prototype</a> </p>
<blockquote>
<p><strong>注意：</strong> 虽然可以通过对象实例访问保存在原型中的值，却不能通过对象实例重写原型中的值。</p>
<p>如果在实例中添加一个属性，该属性与实例中的一个属性同名，那在实例中常见该对象，该属性会将原型中的那个属性屏蔽。</p>
<p><code>hasOwnProperty()</code> 方法可以检测一个属性存在于实例中还是原型中。这个方法只在给定属性存在于对象实例中时，就会返回 <code>true</code> 。</p>
</blockquote>
<h3 id="原型与-in-操作符"><a href="#原型与-in-操作符" class="headerlink" title="原型与 in 操作符"></a>原型与 <code>in</code> 操作符</h3><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ul>
<li>单独使用。 <code>in</code> 操作符会在通过对象能够访问对象时返回 <code>true</code> ，无论存在于实例还是原型中。</li>
<li><code>for-in</code> 循环。返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，既包括存在于实例中的属性和原型中的属性。不可枚举的 <code>constructor</code> 属性，可以通过 <code>Object.keys()</code> 和 <code>Object.getOwnPropertyName()</code> 方法来替代 <code>for-in</code> 循环。</li>
</ul>
<h4 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h4><p>可以通过如下方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'Nicholas'</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">29</span>,</div><div class="line">  <span class="attr">job</span>: <span class="string">'Software Engineer'</span>,</div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的代码将 <code>Person.prototype</code> 设置为等于一个以对象字面量形式创建的对象。</p>
<p><strong>例外</strong> <code>constructor</code> 属性不再指向 <code>Person</code> 。</p>
<p>为了解决上面的问题，可以如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: Person,</div><div class="line">  <span class="attr">name</span>: <span class="string">'Nicholas'</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">29</span>,</div><div class="line">  <span class="attr">job</span>: <span class="string">'Software Engineer'</span>,</div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 以此方式重设 <code>constructor</code> 属性将会导致他的 <code>[[Enumerable]]</code> 特性被设置为 <code>true</code> 默认情况下， <code>constructor</code> 属性是不可枚举的</p>
</blockquote>
<h3 id="原型的动态"><a href="#原型的动态" class="headerlink" title="原型的动态"></a>原型的动态</h3><blockquote>
<p><strong>注意：</strong> 实例中的指针仅指向原型，而不是指向构造函数。</p>
</blockquote>
<h3 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h3><ul>
<li><p>可以取得默认方法的引用。例如。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort);  <span class="comment">// 'function'</span></div><div class="line">alert(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.substring);   <span class="comment">//function</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>还可以定义新方法</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.prototype.startWith = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(text) === <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> msg = <span class="string">'Hello World!'</span>;</div><div class="line">alert(msg.startWith(<span class="string">'Hello'</span>));   <span class="comment">//true</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 不建议在产品化的程序中修改原生对象的原型。</p>
</blockquote>
<h3 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h3><ul>
<li>省略了为构造函数传递初始化参数这一环节，导致所有实例在默认情况下都将取得相同的属性值。</li>
<li>最大的问题在于其共享的本性导致的。原型中所有属性都是实例共享的。对于函数适合。但是对于类型值的属性来说，问题就突出了。</li>
</ul>
<h2 id="组合使用构造函数和原型模式"><a href="#组合使用构造函数和原型模式" class="headerlink" title="组合使用构造函数和原型模式"></a>组合使用构造函数和原型模式</h2><blockquote>
<p>创建自定义类型的最常见方式。</p>
</blockquote>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>构造函数模式用于定义实例属性；原型模式用于定义方法和共享的属性。</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul>
<li>每个实例都会有自己的一份实例属性的副本</li>
<li>但同时又共享着对方法的引用</li>
<li>最大限度的节省内存。</li>
<li>还支持向构造函数传递参数</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="keyword">this</span>.friends = [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: Person,</div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'SoftWare Engineer'</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Greg'</span>, <span class="number">27</span>, <span class="string">'Doctor'</span>);</div><div class="line"></div><div class="line">person1.friends.push(<span class="string">'Van'</span>);</div><div class="line">alert(person1.friends); <span class="comment">// 'Shelby, Court, Van'</span></div><div class="line">alert(person2.friends); <span class="comment">// 'Shelby, Court'</span></div><div class="line">alert(person1.friends === person2.friends); </div><div class="line">  <span class="comment">// false</span></div><div class="line">alert(person1.sayName === person2.sayName);</div><div class="line">  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>此种方式是目前 <code>ECMAScript</code> 中使用<strong>最广泛</strong>、<strong>认同度最高</strong>的一种创建自定义类型的方法。 换句话说，这是用来定义引用类型的一种默认模式。</p>
<h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><p>动态原型模式将所有信息封装在构造函数中，而通过在构造函数中初始化原型（<strong>仅在必要的情况下</strong>），又保持了同事使用构造函数和原型的优点。如例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="comment">// 属性</span></div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="comment">// 方法</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">'function'</span>) &#123;</div><div class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure>
<h2 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h2><blockquote>
<p>主要思想： 创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后返回新的对象。下面是例子。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> o = &#123;&#125;;</div><div class="line">  o.name = name;</div><div class="line">  o.age = age;</div><div class="line">  o.job = job;</div><div class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</div><div class="line">friend.sayName(); <span class="comment">// 'Nicholas'</span></div></pre></td></tr></table></figure>
<p>补充说明：</p>
<ul>
<li>返回的对象与构造函数或者与构造函数的原型属性之间没有关系，也就是说构造函数返回的对象与在构造函数外创建的对象没有什么不同。</li>
<li>不能依赖 <code>instanceof</code> 操作符来确定对象类型。</li>
<li>在能使用别的模式的情况下，不要使用该模式。</li>
</ul>
<h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>没有公共属性 | 其方法也不引用 <code>this</code> 的对象</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="comment">// 创建一个返回的对象</span></div><div class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  <span class="comment">// 可以在这里定义私有变量和函数</span></div><div class="line">  </div><div class="line">  <span class="comment">// 添加方法</span></div><div class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</div><div class="line">friend.sayName(); <span class="comment">// 'Nicholas'</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> JavaScript高级程序设计（第三版） </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo个人博客搭建遇到的问题1]]></title>
      <url>http://blog.pikbug.me/2017/04/06/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%981/</url>
      <content type="html"><![CDATA[<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><ul>
<li>如图1、2</li>
</ul>
<p><img src="/2017/04/06/Hexo个人博客搭建遇到的问题1/QQ20170406-172817@2x.png" alt="1"><br><a id="more"></a><br><img src="/2017/04/06/Hexo个人博客搭建遇到的问题1/QQ20170406-173821@2x.png" alt="2"></p>
<p>对比可知，在<strong>发表于</strong>、<strong>更新于</strong>、<strong>分类于</strong>、<strong>阅读</strong>前边加了一些提示的icon。</p>
<ul>
<li><strong>分析问题</strong></li>
</ul>
<p>一开始我以为存在的问题是我的next主题没有配置好，也就是next目录下的 <code>_config.yml</code> 没配置好，百度、谷歌了好久，没找到答案。<br>后来就去页面看那个icon属于哪一个class，无意之间想去看看class的css文件终于发现了问题所在</p>
<ul>
<li><strong>如图3</strong></li>
</ul>
<p><img src="/2017/04/06/Hexo个人博客搭建遇到的问题1/next配置问题.png" alt="3"></p>
<ul>
<li>找到问题所在</li>
</ul>
<p>一开始图中的display属性是 <code>none</code> 。</p>
<ul>
<li><strong>最后</strong></li>
</ul>
<p>每次解决问题都是在想放弃的时候，感觉很平淡。QAQ</p>
]]></content>
      
        <categories>
            
            <category> 个人博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 个人博客 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[博客更新日志]]></title>
      <url>http://blog.pikbug.me/2017/04/06/web-logs/</url>
      <content type="html"><![CDATA[<h1 id="2016-11-21-更新内容："><a href="#2016-11-21-更新内容：" class="headerlink" title="2016-11-21 更新内容："></a>2016-11-21 更新内容：</h1><h2 id="完成主要的框架工作"><a href="#完成主要的框架工作" class="headerlink" title="完成主要的框架工作"></a>完成主要的框架工作</h2><blockquote>
<ul>
<li>熟悉Hexo</li>
<li>GitHub创建仓库、初始化项目</li>
<li>选取并且确定了Next主题</li>
<li><del>绑定域名blog.pikbug.me</del></li>
<li>新增一篇测试文章<a id="more"></a></li>
</ul>
</blockquote>
<h1 id="2017-02-18-更新内容："><a href="#2017-02-18-更新内容：" class="headerlink" title="2017-02-18 更新内容："></a>2017-02-18 更新内容：</h1><h2 id="主要完成了Next主题的配置工作"><a href="#主要完成了Next主题的配置工作" class="headerlink" title="主要完成了Next主题的配置工作"></a>主要完成了Next主题的配置工作</h2><blockquote>
<ul>
<li>添加「标签」页面</li>
<li>添加「分类」页面</li>
<li>增加404页面</li>
<li><del>增加多说评论</del></li>
<li><del>增加多说分享</del></li>
<li><del>增加cnzz统计</del></li>
<li>增加Algolia搜索功能（未成功奏效）</li>
<li>配置侧边栏的签名</li>
<li>新增一篇测试文章《&lt;暗时间&gt;书摘》</li>
<li>配置RSS</li>
</ul>
</blockquote>
<h1 id="2017-04-06-更新内容："><a href="#2017-04-06-更新内容：" class="headerlink" title="2017-04-06 更新内容："></a>2017-04-06 更新内容：</h1><h2 id="进一步完成主题配置-使功能正常使用"><a href="#进一步完成主题配置-使功能正常使用" class="headerlink" title="进一步完成主题配置 使功能正常使用"></a>进一步完成主题配置 使功能正常使用</h2><blockquote>
<ul>
<li>配置header 确定「首页」、「关于」、「归档」、「标签」、「搜索」</li>
<li>配置Algolia搜索功能，成功运行</li>
<li>增加谷歌统计功能</li>
<li>增加网易云跟帖功能，替代多说评论功能</li>
<li>增加JiaThis分享功能，替代多说分享功能</li>
<li>增加侧边栏版权说明</li>
<li>增加侧边栏社交链接</li>
<li>增加侧边栏友情链接</li>
<li>取消cnzz统计功能</li>
<li>增加阅读次数统计LeanCloud</li>
<li>编辑了footer 样式修改</li>
<li>更换域名解析 将域名解析由 <del><code>blog.pikbug.me</code></del> 改为 <code>pikbug.me</code><br>  <em><em>注意：</em></em> <ol>
<li>更改域名解析之前前要将 <code>source/</code> 的 <code>CNAME</code> 文件中解析到的地址改成你要解析到的地址 也就是 <code>pikbug.me</code></li>
<li>不知道到底要不要将 <code>blog</code> 下的 <code>.deploy_git</code> 删除掉在进行 如下操作，我是删掉了该目录</li>
<li>首先执行 <code>hexo algolia</code> 命令，刷新索引，当algolia网站的 <code>Indices</code> 页面显示如图所示<br><img src="/2017/04/06/web-logs/algolia-update-indexes.png" alt="png"><br>说明操作成功</li>
<li>再执行 <code>hexo g -d</code> 命令就可以生成静态博客并推送到GitHub了</li>
</ol>
</li>
<li>增加 <strong>发布于</strong>、<strong>更新于</strong>等多个标签前的icon 详情请看 <a href="http://pikbug.me/2017/04/06/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%981/" target="_blank" rel="external">这篇文章</a></li>
</ul>
</blockquote>
<h1 id="2017-04-07-更新内容："><a href="#2017-04-07-更新内容：" class="headerlink" title="2017-04-07 更新内容："></a>2017-04-07 更新内容：</h1><h2 id="进一步完成主题配置-完善网页显示"><a href="#进一步完成主题配置-完善网页显示" class="headerlink" title="进一步完成主题配置 完善网页显示"></a>进一步完成主题配置 完善网页显示</h2><blockquote>
<ul>
<li>增加版权声明 如图：<br><img src="/2017/04/06/web-logs/creative-commons.png" alt="creative-commons"></li>
<li>修改了一个菜单的icon 如图</li>
<li>将鼠标滑过标题链接时的显示颜色由黑色改为绿色<br><img src="/2017/04/06/web-logs/2017-04-07-update.png" alt="2017-04-07-update"></li>
<li>将网站的头像（avator.png）有正方形改为圆形</li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 个人博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 个人博客 </tag>
            
            <tag> web-logs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《暗时间》书摘]]></title>
      <url>http://blog.pikbug.me/2017/02/18/%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<h1 id="知识结构"><a href="#知识结构" class="headerlink" title="知识结构"></a>知识结构</h1><p>1.抓住不变量。<br>1️⃣底层知识：英语以及编程的语法知识等<br>2️⃣工具<br>3️⃣要熟悉自己的工具 熟练运用 熟悉运用<br><a id="more"></a></p>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>本质：学习新知识的带着第三只眼睛判断哪些知识是变量，或者不易变量，是否可以在用的时候查手册即可。<br>🤔补充：学习新知识的时候：⚡︎本质是什么；第一原则是什么；改制时的（体系或者层次）结构是什么。<br>😀现在是一个信息泛滥的时代，→需要学会在浩瀚的信息中选择我们需要的信息；→避免被不好的信息左右我们的大脑。<br>习惯的养成<br>〶江山易改，本性难移。<br>我们评价一个信念的标准是satisficing原则，即足够，能行就好。<br>🙃可以改变习惯<br>1️⃣认识到习惯的改变不是一两天实现的，承认它的难度；<br>2️⃣真想改掉自己习惯，注意观察自己的习惯，把要克服的习惯的那个自我当做自己的一个孩子，然后去打败他；<br>🐷我喜欢这句话：知难而不退，值得做的事情几乎总是如此😀。<br>我在南大的七年<br>父亲告诉我的第二件事情是：遇到问题，找书去就行。<br>🤔改变一生的两个习惯：1️⃣学习东西不觉得是累，自得其乐。2️⃣学习新东西的方法。<br>🐶与父母共同的性格：遇到麻烦和困难的事情从不放弃。<br>🐱我在CSDN上开了博客，开始学习C++和编程中的一些总结。这个博客一直写到离开南大，伴随了我真个七年的学习和成长，回过头去看像时光机一样，能够看到一路过来我都关注了什么是怎么想的，以及对一些事情的看法是怎么变化的。这些东西如果不记录下来，会逐渐忘记，也就无法参照过去的自己，对未来提供更好的借鉴了。所以我一直把记录当做一个很重要的工具。另外我也同感这个博客认识了很多朋友，得到了很多的帮助。</p>
<h1 id="逃出你的肖申克（一）"><a href="#逃出你的肖申克（一）" class="headerlink" title="逃出你的肖申克（一）"></a>逃出你的肖申克（一）</h1><p>为什么我们常说很多时候一定邀请神经理之后才明白<br>1️⃣切身体会。亲身经理负面事件带来的情绪反应比看着或者听说别人遭受一个同样的时间感受到的强烈的多，形成的情绪记忆更持久。心理学上，自己无法从强度上真正感同身受别人的痛苦。<br>2️⃣别人口中的故事。别人口中的故事也许只是他们的想法，你自己亲身经历同样的事情也许完全有事另外一种想法。<br>3️⃣为什么。很难说服自己A选项优于B选项，直到最终自己在某一条路上撞了南墙才肯死心。<br>4️⃣世界是复杂的。各种错综复杂的因素和响应下，用单一因果来解释事件几乎总是不恰当的。<br>5️⃣未来是不确定的。外界因素是不可控的，我们能做得到只是做好头脑准备，尽量不错失机会。成功并不是仅仅取决于个人因素。个人因素往往只是成功的一个既非充分又非必要的条件，所谓谋事在人成事在天；但无需悲观，因为毫无疑问的是，改变个人因素的却能够增加成功的几率。<br>6️⃣别人的道理，自己的事情。<br>🐹解决问题的两步思维步骤：①根据问题从记忆系统中提取以往成功的方案；②多多思考观察自己，抽象其本质。<br>7️⃣认知失调与自我辩护<br>8️⃣失败即成功<br>9️⃣情绪对照<br>🔟天性 ①一个理性大脑②一个原始大脑。 如果你总是感到满足的话，就不会去进取，在一个残酷的优胜劣汰的环境中，你的这种不思进取的基因就会被淘汰。<br>我们常常需要用理性的声音去说服内心的原始人。<br>十一 习惯</p>
<p>亲身经历了就一定明白吗<br>⒈很傻很天真的条件反射<br>①没有得到好的结果并不代表你的过程就错了<br>②结果正确也不代表方法就一定正确<br>③客观做法：而不是看着单次的结果 —— 因为再好的过程也可能会偶尔失利，但从长远统计来看，好的过程总体上必然导致好的结果（《别做正常的傻瓜》第12章：“抓住老鼠的一定是好猫吗 —— 结果偏见”对此介绍）<br>⒉认知偏见<br>推荐书籍《How we know what isn’t so》 其中包含一些经典的谬误<br>⒊情绪系统<br>①日常的决策与判断强烈地依赖与情绪系统的输出<br>②始终别忘记情绪系统只是一个比较粗糙的判断与决策系统，并且它很多时候是为了适应远古时代而非现代社会的。</p>
<p>不需要亲历也能够明白——理性的力量<br>①我满大多是让事实替代我们进行思考和推理，我们从失败当中获得信息。<br>②人最强大的能力是社会学习：普通人从自己的错误中学习，聪明人从别人的错误中学习。<br>③人最强大的另外一个能力则是：归纳和判断。<br>∑我们再打澳洲越走越远，在现实中越走越稳。我们在大脑中失败的次数越多，在现实中失败的次数就会越少。<br>我的感受：多思考！</p>
<h1 id="逃出你的肖申克（二）"><a href="#逃出你的肖申克（二）" class="headerlink" title="逃出你的肖申克（二）"></a>逃出你的肖申克（二）</h1><p>①这些先验假设并不蕴藏咋图片中，而是在我们长期的生活中无意识统计出来的，或者干脆就是漫长的进化过程中帅选出来的有价值的先验假设——正如婴儿天生吃奶起就懂得吮吸一样。<br>②有时候打破偏见的唯一途径就是开阔视野，多积累知识，以及和具有不同知识背景的人讨论。—— 当你知道越多你就懂得越少<br>③需要与不同背景的人进行讨论，弥补个人经验知识的局限性导致的偏差，并时常使用以下两句话来提醒自己保持Open Mind：这只是一种可能；<br>想不出其他解释不代表就不存在其他的解释。</p>
<h1 id="逃出你的肖申克（三）"><a href="#逃出你的肖申克（三）" class="headerlink" title="逃出你的肖申克（三）"></a>逃出你的肖申克（三）</h1><p>——遇见20万年前的自己<br>①世界上最痛苦的事情不是和别人作斗争，而是和自己作斗争。<br>②大脑决策：直觉进行决策；理性分析<br>③emotion和motion在词源上是同源词。人们了解到了情绪和动力的关系<br>④我们对于未来的惩罚和收益估计不足，更倾向于就眼下的损益进行决策，会导致我们目光短浅。<br>⑤很多时候我们只是生活在信息社会的远古人。</p>
<h1 id="逃出你的肖申克（四）"><a href="#逃出你的肖申克（四）" class="headerlink" title="逃出你的肖申克（四）"></a>逃出你的肖申克（四）</h1><p>1⃣️当你觉得自己想的很有道理，无懈可击，客观公正的时候，你是否真正像你认为的那样客观公正呢？Artemus Ward曾经说过：“并不是那些我们不知道的事情让我们陷入麻烦，而是那些我们认为自己知道，却实际上是错误的知识，让我们陷入麻烦。”客观意味着承认存在未知信息的可能性，理性意味着能够从对立面的视角去看问题和思考。<br>2⃣️学会质疑自己<br>3⃣️与其让别人指出自己的错误，不如自己试着去发现自己的错误。<br>4⃣️大脑符合用进废退的原理，越经常使用的区域越发达。<br>5⃣️习惯之所以难以改变改变，就是因为习惯是自我巩固的——越用越强，越强越用。<br>6⃣️能够改变既有的习惯，依靠的不是自制力，而是知识。<br>7⃣️分散注意力<br>书写时为了更好地思考<br>书写的好处：<br>1⃣️书写是对思维的备忘。<br>2⃣️书写是对思维的缓存。<br>3⃣️书写是与自己的对话<br>4⃣️书写是与别人的交流<br>5⃣️有时候，语言自己也会思考</p>
<h1 id="为什么你从现在开始就应该写博客"><a href="#为什么你从现在开始就应该写博客" class="headerlink" title="# 为什么你从现在开始就应该写博客"></a># 为什么你从现在开始就应该写博客</h1><p>🙃写一个博客有很多的好处，却没有任何明显的坏处<br>🐹用博客的形式来记录下你有价值的思考，会带来很多好处，却没有很明显的坏处。<br>1⃣️能够交到很多志同道合的朋友<br>2⃣️书写是为了更好地思考<br>3⃣️“教”是最好的“学”。一旦你把自己潜意识里面的东西从幕后拉出来，你就有了面对并反思它们的可能性，而不是任它们的可能性，而不是任它们在幕后阴险地左右你的思维。去教一个完全不懂的人，则是一个最强大和彻底的反思途径<br>4⃣️讨论是绝佳的反思比较你和别人观念之间的差别，进一步讨论中她们就会不断迫使对方拿出更深层滋的理由。<br>5⃣️激励你去持续学习和思考。<br>6⃣️学会持之以恒地做一件事情<br>7⃣️一个长期的价值博客是一份很好的简历。<br>怎样做到长期写一个价值博客<br>因为你在思考和总结从而必须写下里，写博客也就变成了副产品。<br>让你自己成为一个持续学习和思考的人，并只写你真正思考和总结的产物，其他的一切都会随之而来。——只做你最感兴趣的事情，钱会随之而来。<br>可能出现的问题以及怎样应对<br>意志力很大程度上来源于正确的方法，而非天生。<br>1⃣️担心别人认为没有价值。<br>2⃣️担心想法太幼稚或有漏洞等等被别人笑话。<br>3⃣️得不到鼓励 overnight success takes a long time（一夜成名需要很长时间）<br>4⃣️写不出来  能够吧问题长时间停留在潜意识中是一种技能，能够嗲来很大的好处，停留越久你越琢磨得透彻，比别人看到的就越多。<br>我不想与我不能<br>自利归因 就是对一件事情发生的原因归结为对自己有利的那种情况。——不能给自己难堪，不能让自己下不来台。功劳都给自己买责任都给别人担。<br>自利归因表现形式：注意力等于现实。即，观察者偏见所起的作用就像一个过滤器——唯心主义人择原理的话就是——世界是这个样子就因为我看到他是这个样子的。</p>
<p>遇到问题为什么应该自己动手<br>知其所以然<br>🐹我们要的不是相对论，而是诞生相对论的那个大脑。我们要的不是金蛋，而是下金蛋的那只鸡。<br>思考问题的两种思维方式：<br>1⃣️联想。此方式不是最佳的思维方式。充满了错误的可能。<br>2⃣️演绎&amp;归纳。比“联想”的思维方式好一点。<br>人类解决问题的两大思维方式实际上都有很大的试错成分（探索）。<br>😎当我们遇到问题时：<br>1⃣思维的漫长繁杂的过程已经在大脑里面淡化的差不多了；<br>2⃣思维过程对我们的空气和水，而“鱼是最后一个感觉到水的”，我们感觉不到思维法则本身的存在，我们只是不知不觉运用它。<br>3⃣我们的目标是问题的解，过程是过程。目的是目的。<br>4⃣感到介绍思维过程是不相干的。不能放弃对求解过程。<br>思维过程的极其重要的价值：<br>1.内隐化<br>2.跨情景运用。思维法则也是记忆。<br>3.对问题解的更多记忆提取线索<br>4.包含了多得多的知识。<br>5.重在分析推理，而不是联想。<br>6.寻找该算法的原始出处。<br>7.原始出处气势未必就都推心置腹和你讲的那么到位。<br>8.不仅仅学习别人的思路，整理自己的思路也是极其重要的。<br>为什么有必要知其所以然</p>
]]></content>
      
        <categories>
            
            <category> 日志 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> 个人博客 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello Blog]]></title>
      <url>http://blog.pikbug.me/2016/11/21/Hello%20World/</url>
      <content type="html"><![CDATA[<p>这是一个新的开始，花了一下午外加一晚上的时间，差不多趟了所有的坑。<br><a id="more"></a><br>终于搭好了个人博客。接下来的日子，就需要慢慢来优化了！大家拭目以待！</p>
]]></content>
      
        <categories>
            
            <category> 日志 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 日记 </tag>
            
            <tag> 测试 </tag>
            
            <tag> 个人博客 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
